[TOC]

# 第四章 栈、队列和递归

- **栈(stack)**和**队列(queue)**是线型表的特殊情况。
- **栈**只可在表尾插入和删除元素。
- **队列**只可在表尾插入元素，在表头删除元素。
- **递归**是一种有效的算法设计方法。本章介绍递归的概念和过程以及递归工作栈，并讨论用栈实现递归过程的非递归化。


## 4.1 栈

- **栈顶(top)**：允许**插入**和**删除**的一端。
- **栈底(bouttle)**：不允许插入和删除的另一端。
- **空栈**：无元素的栈。
- 栈中元素**后进先出**(last in first out, LIFO)。

  - 入栈的过程：
    - ![image-20221207141725408](https://martin-red-1315612947.cos.ap-shanghai.myqcloud.com/PicGo%E5%9B%BE%E5%BA%8A/image-20221207141725408.png)
  - 出栈的过程：
    - ![image-20221207141757376](https://martin-red-1315612947.cos.ap-shanghai.myqcloud.com/PicGo%E5%9B%BE%E5%BA%8A/image-20221207141757376.png)
- 栈的**基本操作**：

  1. 初始化。
  2. 求长度。
  3. 取栈顶元素。
  4. 入栈。
  5. 出栈。
  6. 判断是否为空栈。
  7. 清空。


### 4.1.1 顺序栈

- 顺序栈(seqential stack)就是用顺序方式存储的栈。


#### 顺序栈的类模板定义

- 结构图：

  - ![image-20221207142448556](https://martin-red-1315612947.cos.ap-shanghai.myqcloud.com/PicGo%E5%9B%BE%E5%BA%8A/image-20221207142448556.png)

- 定义代码：

- ```C++
  //顺序栈的类模板实现
  template<class ElemType>
  class SeqStack
  {
      protected:
      //顺序栈的数据成员：
      int top;    //栈顶指针
      int maxSize;    //栈的最大容量
      ElemType *elems;    //元素存储空间
      public:
      //顺序栈的函数成员：
      SeqStack(int size = DEFAULT_SIZE);  //构造函数
      virtual ~SeqStack();    //析构函数
      int GetLength() const;  //求栈长度
      bool IsEmpty() const;   //判断栈是否为空
      void Clear();           //将栈清空
      void Traverse(void (*Visit)(const ElemType &)) const;   //遍历栈
      Status Push(const ElemType e);  //入栈
      Status Top(ElemType &e) const;  //取栈顶元素
      Status Pop(ElemType &e);        //出栈
      SeqStack(const SeqStack<ElemType> &s);  //复制构造函数
      SeqStack<ElemType> &operator = (const SeqStack<ElemType> &s);    //赋值语句重载
  }
  ```

#### 顺序栈的实现

1. 顺序栈的构造函数

   ```C++
   template<class ElemType>
   SeqStack<ElemType>::SeqStack(int size)
   {
       maxSize=size;
       if (elems != NULL) delete[]elems;
       elems = new ElemType[maxSize];
       top = -1;
   }
   ```

2. 顺序栈的析构函数

   ```C++
   template<class ElemType>
   SeqStack<ElemType>::~SeqStack()
   {
       delete[] elems;
   }
   ```

3. 遍历顺序栈

   ```c++
   template<class ElemType>
   Status SeqStack<ElemType>::Traverse(void(*Visit)(const ElemType &)) const
   {
       for(int i=top; i>=0; i--)
           (*Visit)(elems[i]);
   }
   ```

4. 入栈

   ```c++
   template<class ElemType>
   Status SeqStack<ElemType>::Push(const ElemType e)
   {
       if(top == maxSize)
           return OVER_FLOW;
       else
       {
           elems[++top]=e;
           return SUCCESS;
       }
   }
   ```

5. 取栈顶元素

   ```c++
   template<class ElemType>
   Status SeqStack<ElemType>::Top(ElemType &e) const
   {
       if (IsEmpty())
           return UNDER_FLOW;
       else {
           e = elems[top];
           return SUCCESS;
       }
   }
   ```

6. 出栈

   ```c++
   template<class ElemType>
   Status SeqStack<ElemType>::Pop(ElemType &e)
   {
       if(IsEmpty())
           return UNDER_FLOW;
       else{
           e=elems[top--];
           return SUCCESS;
       }
   }
   ```
   
7. 顺序栈有时采用这样的结构：**将两个栈放到同一个数组中**，栈底分别在数组两端，当两个栈的栈顶相遇时，才会发生栈满从而溢出。这样可以让两个栈共享长度为size的空间。

  - ![image-20221207160902394](https://martin-red-1315612947.cos.ap-shanghai.myqcloud.com/PicGo%E5%9B%BE%E5%BA%8A/image-20221207160902394.png)

### 4.1.2 链式栈

- **链式栈(linked stack)**就是用链表的方式存储栈中元素。与顺序栈相比，链式栈对于同时使用多个栈的情况下可以共享存储。

- 对于栈，使用**不带头结点**的链表会更加方便。链表的标头即为栈的栈顶，入栈和出栈都在表头进行。


#### 链式栈的类模板定义

- 链式栈的结构图

  ![image-20221207161231776](https://martin-red-1315612947.cos.ap-shanghai.myqcloud.com/PicGo%E5%9B%BE%E5%BA%8A/image-20221207161231776.png)

- 链式栈的定义代码

  ```c++
  template<class ElemType>
  class LinkStack
  {
  protected:
      //链栈的数据成员
      Node<ElemType> *top;
  public:
      //链栈的函数成员
      LinkStack();
      virtual ~LinkStack();
      int GetLength() const;
      bool IsEmpty() const;
      void Clear();
      void Traverse((*Visit)(const ElemType &)) const;
      Status Push(const ElemType &e) const;
      Status Top(ElemType &e) const;
      Status Pop(ElemType &e);
      LinkStack(const LinkStack<ElemType> &s);
      LinkStack<ElemType> &operator = (const LinkStack<ElemType> &s);
  }
  ```

#### 链式栈的实现

1. 构造函数

   ```C++
   template<class ElemType>
   LinkStack<ElemType>::LinkStack()
   {
       top = NULL;
   }
   ```

2. 析构函数

   ```C++
   template<class ElemType>
   LinkStack<ElemType>::~LinkStack()
   {
       Clear();
   }
   ```

3. 求链式栈的长度

   ```C++
   template<class ElemType>
   int LinkStack<ElemType>::GetLength() const
   {
       int count = 0;
       Node<ElemType> *p;
       for (p = top; p != NULL; p = p->next)
       {
           count++;
       }
       return count;
   }
   ```

4. 清空链式栈

   ```C++
   template<class ElemType>
   void LinkStack<ElemType>::Clear()
   {
       Node<ElemType> *p;
       while (top != NULL)
       {
           p = top;
           top = top->next;
           delete p;
       }
   }
   ```

5. 遍历链式栈

   ```C++
   template<class ElemType>
   void LinkStack<ElemType>::Traverse(void (*Visit)(const ElemType &)) const
   {
       Node<ElemType> *p;
       for(p = top; p != NULL; p = p->next)
       (*Visit)(p->data);
   }
   ```

6. 入栈

   ```C++
   template<class ElemType>
   Status LinkStack<ElemType>::Push(const ElemType e)
   {
       Node<ElemType> *p = new Node<ElemType>(e,top);
       if (p = NULL)
           return OVER_FLOW;
       else
       {
           top = p;
           return SUCCESS;
       }
   }
   ```

7. 取栈顶元素

   ```C++
   template<class ElemType>
   Status LinkStack<ElemType>::Top(ElemType &e) const
   {
       if(IsEmpty())
           return UNDER_FLOW;
       else
       {
           e = top->data;
           return SUCCESS;
       }
   }
   ```

8. 出栈

   ```C++
   template<class ElemType>
   Status LinkStack<ElemType>::Pop(ElemType &e)
   {
       if(IsEmpty())
           return UNDER_FLOW;
       else
       {
           Node<ElemType>* p = top;
           e = top->data;
           top = top->next;
           delete p;
           return SUCCESS;
       }
   }
   ```

### 4.1.3 栈的应用——表达式求值

- 表达式求值是编译系统中的基本问题之一，也是栈的一个非常重要的应用。
- 这里重点讨论利用后缀表达式求值以及中缀表达式转化为后缀表达式的算法实现。
- 什么是**中缀表达式**：
  - 在通常的表达式中，二元运算符总是置于与之相关的两个运算对象之间，这种表达法称为**中缀表达式**。如：$(32-26)*5+28/4$
  - 为了正确执行中缀表达式的计算，必须知道操作符的优先级和运算次序。
- 什么是**后缀表达式**：
  - 对中缀表达式的计算，并非按照运算符出现的自然顺序来执行其中的各个运算，而是根据运算符间的优先级关系来确定运算的次序，此外，还应兼顾括号的规则。因此，要从中缀表达式直接产生目标代码一般比较麻烦。
  - 1929年波兰逻辑学家提出了另一种表达式的表示方法，按此方法，每一运算符都置于其运算对象之后，称为**后缀表达式**。
  - 举例：`A*B-C`变为`AB*C-`；又如`(32-26)*5+28/4`变为`32 26 - 5 * 28 4 / +` 
  - 这种表示法的特点是：表达式中一系列运算是按运算符出现的顺序进行的，故无需使用括号来强调运算顺序，因此又称为无括号式。
  - 顺便一提，类似的也有前缀表达式，因为只是和后缀表达式形式上不同，就不做展开。

#### 后缀表达式的计算

- 后缀表达式计算不需要使用括号，也不需要考虑操作符的优先级。它只需要利用一个栈存放依次输入的操作数和运算的中间结果即可非常方便地完成后缀表达式的计算。

- 具体过程为：

  - 从左向右扫描。
  - 遇操作数，将之压入栈中。
  - 遇操作符，根据操作符性质，从栈中取出正确数目的操作数，进行一次运算，将运算结果压入栈中。
  - 当扫描完毕，后缀表达式的计算也就完成了。

- 认为后缀表达式中只能出现操作数和算数运算符，不允许有其他符号，且操作数之间用空格分隔，操作符以`#`表示结束。代码实现如下：

  ```
  ```

  

