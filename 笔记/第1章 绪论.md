[TOC]

# 第1章 绪论

## 主要内容

- 介绍数据结构的概念，以及算法复杂度的分析
- 学习要点：
  1. 知道所有的定义和术语相关的，特别是数据结构的类型和存储。
  2. 熟悉C++。
  3. 理解概念和掌握分析算法，算法复杂度的方法。
- 练习题
  - P~12~10；P~44~应用题2；P~11~应用题1,2,3

## 1.1 程序 = 算法 + 数据结构

- 该公式是计算机科学家，图灵奖获得者 N.Wirth 提出的。
- **数据结构**是计算机存储、组织数据的方式。
- **算法**是对解决问题的过程的描述。
- 数据结构和算法是构成程序的两个重要的组成部分。
- 数据结构和解题的算法并不是一个整体。
- 有人主张将该公式协作`（算法+数据结构）=程序`，用来体现面向对象的方法

## 1.2 数据结构的基本概念

- **数据**：数据（data）是信息的载体，是描述客观事物的数、字符、图形、图像、声音以及所有能输入计算机中并被计算机程序识别和处理的符号的集合。

- **数据元素和数据项**：数据的基本单位是**数据元素**（data element）。一个数据元素可由若干个**数据项**（date item）组成，数据项是数据的最小单位。

  - 举例：对于人事登记表的例子，一个职工的记录就是一个**数据元素**。它包括：编号、姓名、性别、出生日期、婚否、基本工资六个**数据项**。

- **数据对象**：具有相同特性的一系列数据元素组成了数据对象。数据对象是数据的子集。

- **数据结构**：数据结构不仅包含数据，还需要描述这些数据元素之间的相互关系。

- 在实际应用中各种数据元素都不是孤立存在的，它们之间存在着某种关系。这种关系就是“结构”。

- 数据结构根据数据元素之间关系的不同分为两类：

  - 线性结构、非线性结构。
  - 这两类结构通常可再分为下列4个基本结构：

  ![img](https://martin-red-1315612947.cos.ap-shanghai.myqcloud.com/PicGo%E5%9B%BE%E5%BA%8A/asynccode)

- 数据结构根据其视点的不同分为两类：
  - 逻辑结构和物理结构
  - **逻辑结构**属于用户视图，是用户所看到的数据结构，是面向问题的。它描述的是数据元素之间的逻辑关系。
  - **物理结构**又称为存储结构，是数据的逻辑结构在计算机中的物理存储方式，它数据具体实现的视图，是面向计算机的。
- 数据的逻辑结构和物理结构是密切相关的两个方面，一般来说，算法设计是基于数据的逻辑结构，而算法实现则基于数据的物理结构。

## 1.3 算法性能与复杂度

- **算法**就是解某种问题的任何专门的方法
- **算法**在计算机科学里`用计算机解题的精确描述`

### 1.3.1 算法的定义

- 算法定义为一个用于实现某个特定任务的又穷指令集，这些指令规定了一个运算序列。
- 算法的**特性**：
  1. **输入性**
  2. **输出性**
  3. **确定性**：算法中的每一条指令应含义明确，无歧义，即对每一种情况，需要执行的动作都应严格地规定清楚。
  4. **有穷性**：算法中指令执行序列是有穷的。
  5. **有效性**：每条指令必须是基本的、可行的。
- 算法的**描述**：
  - 自然语言描述：直接，易于理解；容易出现二义性，语句冗长，分支及循环结构不易表述。
  - 流程图描述：直观、清晰、易懂，便于检查、修改和交流；严密性不如代码，灵活性不如自然语言，对大型算法描述困难。
  - 计算机程序设计语言描述：清晰明了，一步到位，计算机能处理；抽象性不好，容易让人就拘泥于计算细节。

### 1.3.2 算法的性能标准

- 算法的**标准**
  1. **正确性**：是最重要也是最基本的标准。
  2. **可用性**：算法应能方便地使用。有良好的界面，完备的用户文档即为可用性好。
  3. **可读性**：算法应当是可读的，易于理解的。
  4. **效率**：和算法的时间复杂度和空间复杂度有关。
  5. **健壮性**：当输入非法数据后，算法能够适当处理，而不产生不可预料的结果，则该算法健壮。算法健壮性要求算法中有对输入参数、打开文件、读文件记录以及子程序调用状态等操作的检错、报错和纠错功能。
- 实际上设计算法时，上面几条标准不可兼顾。可用性强、可读性强会降低算法的效率。对于效率本身，时间复杂度和空间复杂度也是难以兼顾。一般优先考虑时间复杂度。

### 1.3.3 算法的复杂度

- 算法效率的度量分为**事前估计**和**后期测试**，但是后期测试测定受环境影响较大，我们分析算法复杂度常用事前估计。

  #### 算法的时间复杂度

  - 算法的时间复杂度仅与所求解的规模有关，它是问题规模的函数。
  - **问题规模**用 n 来表示。
  - 从算法中选取一种基本操作，我们分析这个基本操作执行的次数。以此度量算法的时间复杂度。
  - 分析常用O(f(n))表示法，读作“大O的fn”。
    - 算法时间复杂度描述的是：随着问题规模n的增大，算法所执行需要的时间的增长率和问题规模增长率之间的关系。
    - 在表示f(n)的值的时候，常系数不计，对于一般多项式的部分，只计最高次项。
  - **平均**时间复杂度：有些时候，算法的时间复杂度会随着算法中数据元素的取值而不同，对这类算法，可以分析其时间复杂度的平均值。认为各种取值概率相等，求时间复杂度的期望，即为平均时间复杂度。
  - **最大**时间复杂度：实际情况中，算法处理的数据是不可预知的，平均复杂度没有什么意义，常见的做法是计算出算法在最坏情况下的时间复杂度，来确定一个上界。
  - 一般来说，具有**多项式**的时间复杂度的算法是可接受的算法，对于有**指数**时间复杂度的算法，只有当n足够小时才是可用的算法。
  
  #### 算法的空间复杂度
  
  - 算法的空间复杂度作为算法所需存储空间的量度。
  - 记作`S(n)=O(f(n))`
  - 表示随着问题规模n的增大，算法执行所需存储空间的增长率和`f(n)`的增长率是一样的。
  - 这里所说的存储空间不是程序本身、常数、指针所需要的存储空间，也不是指输入数据所占用的存储空间，而是指**解题过程所需要的辅助空间**
  - 一般来说，只有完成**同一功能**的算法之间才具有空间复杂度上的可比性。
